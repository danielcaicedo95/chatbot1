# app/services/conversation.py

from datetime import datetime
import json
import re
import traceback
from difflib import get_close_matches

from app.utils.memory import user_histories
from app.clients.gemini import ask_gemini_with_history
from app.clients.whatsapp import send_whatsapp_message, send_whatsapp_image # Asumimos que estas NO son async
from app.services.supabase import save_message_to_supabase
from app.services.products import get_all_products, get_recommended_products
from app.services.orders import process_order # Aseg√∫rate que esta funci√≥n est√© bien definida
from app.utils.extractors import extract_order_data # Aseg√∫rate que esta funci√≥n est√© bien definida

# Campos requeridos para que un pedido se considere completo y se pueda procesar desde el JSON del LLM
REQUIRED_FIELDS = ["name", "address", "phone", "payment_method"]

async def handle_user_message(body: dict):
    try:
        entry = body.get("entry", [{}])[0]
        changes = entry.get("changes", [{}])[0]
        messages = changes.get("value", {}).get("messages")

        if not messages:
            return

        msg = messages[0]
        raw_text = msg.get("text", {}).get("body", "").strip()
        from_number = msg.get("from")

        if not raw_text or not from_number:
            return

        current_time = datetime.utcnow()
        user_histories.setdefault(from_number, []).append({
            "role": "user",
            "text": raw_text,
            "time": current_time.isoformat()
        })
        await save_message_to_supabase(from_number, "user", raw_text, timestamp=current_time)

        productos = await get_all_products()
        if not productos:
            print("‚ö†Ô∏è No se pudieron obtener los productos.")
            send_whatsapp_message(from_number, "Lo siento, estoy teniendo problemas para acceder a nuestro cat√°logo en este momento. Por favor, int√©ntalo m√°s tarde. üôè")
            return

        # --- Funciones auxiliares (build_catalog, match_target_in_catalog, etc.) ---
        # (Tu c√≥digo existente para estas funciones. Aseg√∫rate que `build_catalog` y `match_target_in_catalog`
        #  est√©n bien implementadas y sean robustas como discutimos anteriormente)
        def extract_labels(obj):
            labels = []
            def _extract(o):
                if isinstance(o, dict):
                    for v in o.values():
                        _extract(v)
                elif isinstance(o, list):
                    for v in o:
                        _extract(v)
                elif isinstance(o, str):
                    labels.append(o)
            _extract(obj)
            return labels

        def build_catalog(productos_list):
            catalog = []
            for p in productos_list:
                variants_data = []
                for v in p.get("product_variants", []):
                    opts = v.get("options", {})
                    if not opts:
                        continue
                    option_key = next(iter(opts.keys()))
                    option_value = str(opts.get(option_key, "")).lower()
                    
                    display_label_parts = [f"{k_opt}:{v_opt}" for k_opt, v_opt in opts.items()]
                    catalog_variant_label_parts = [f"{k_opt}:{str(v_opt).lower()}" for k_opt, v_opt in opts.items()]

                    variants_data.append({
                        "id": v["id"],
                        "value": option_value, 
                        "display_label": ", ".join(display_label_parts),
                        "catalog_variant_label": ",".join(catalog_variant_label_parts),
                        "images": [img["url"] for img in p.get("product_images", []) if img.get("variant_id") == v["id"]]
                    })
                main_imgs = [img["url"] for img in p.get("product_images", []) if img.get("variant_id") is None]
                catalog.append({"name": p["name"], "variants": variants_data, "images": main_imgs, "description": p.get("description","")}) # A√±ad√≠ descripci√≥n
            return catalog

        def match_target_in_catalog(catalog_list, productos_list, target_str):
            target_str = target_str.strip().lower()
            if not target_str: return None, None

            # B√∫squeda exacta y combinada primero
            for entry_cat in catalog_list:
                prod_name_lower = entry_cat["name"].lower()
                for v_catalog in entry_cat["variants"]:
                    if v_catalog["value"] == target_str: # Ej: target "amarillo"
                        prod = next((p for p in productos_list if p["name"] == entry_cat["name"]), None)
                        return prod, v_catalog
                    if prod_name_lower in target_str and v_catalog["value"] in target_str: # Ej: target "tequila amarillo"
                        prod = next((p for p in productos_list if p["name"] == entry_cat["name"]), None)
                        return prod, v_catalog
            
            for entry_cat in catalog_list: # Ej: target "tequila jose cuervo"
                if entry_cat["name"].lower() == target_str:
                    prod = next((p for p in productos_list if p["name"] == entry_cat["name"]), None)
                    return prod, None

            # B√∫squeda difusa
            all_choices = []
            choice_to_item_map = {}
            for entry_cat in catalog_list:
                pn_lower = entry_cat["name"].lower()
                all_choices.append(pn_lower)
                choice_to_item_map[pn_lower] = (entry_cat["name"], None)
                for v_catalog in entry_cat["variants"]:
                    variant_full_name = f"{pn_lower} {v_catalog['value']}"
                    all_choices.append(v_catalog["value"])
                    choice_to_item_map[v_catalog["value"]] = (entry_cat["name"], v_catalog["value"])
                    all_choices.append(variant_full_name)
                    choice_to_item_map[variant_full_name] = (entry_cat["name"], v_catalog["value"])

            best_matches = get_close_matches(target_str, list(set(all_choices)), n=1, cutoff=0.65) # Aumentar un poco el cutoff
            if best_matches:
                match_str = best_matches[0]
                matched_prod_name_map, matched_variant_value_map = choice_to_item_map[match_str]
                
                prod_obj = next((p for p in productos_list if p["name"] == matched_prod_name_map), None)
                if not prod_obj: return None, None

                if matched_variant_value_map:
                    catalog_entry_found = next((ce for ce in catalog_list if ce["name"] == matched_prod_name_map), None)
                    if catalog_entry_found:
                        variant_obj_catalog = next((vo for vo in catalog_entry_found["variants"] if vo["value"] == matched_variant_value_map), None)
                        return prod_obj, variant_obj_catalog
                return prod_obj, None
            return None, None


        async def handle_image_request_logic():
            try:
                catalog_data = build_catalog(productos)
                # Simplificar el cat√°logo para el prompt de im√°genes
                simplified_catalog_for_prompt = []
                for p_entry in catalog_data:
                    variant_display_labels = [v["display_label"] for v in p_entry["variants"]]
                    simplified_catalog_for_prompt.append({
                        "name": p_entry["name"],
                        "variants": variant_display_labels if variant_display_labels else "No tiene variantes espec√≠ficas listadas"
                    })

                prompt_obj = {
                    "user_request": raw_text,
                    "catalog_summary": simplified_catalog_for_prompt,
                    "instructions": [
                        "Detecta si el usuario quiere ver una imagen de un producto o variante del cat√°logo.",
                        "Responde en JSON plano (sin Markdown).",
                        "Si quiere im√°genes: {\"want_images\": true, \"target\": \"nombre exacto del producto o variante, ej: 'Tequila Jose Cuervo amarillo', 'Aguardiente Nari√±o', 'azul' (si el producto ya est√° en contexto)\"}",
                        "Si no quiere im√°genes: {\"want_images\": false}",
                        "Si no est√°s seguro del producto/variante: {\"want_images\": true, \"target\": null, \"clarification_needed\": \"¬°Claro! ¬øDe qu√© producto o variante te gustar√≠a ver una foto? Por favor, s√© lo m√°s espec√≠fico posible. üòä\"}",
                    ]
                }

                hist = [m for m in user_histories.get(from_number, []) if m["role"] in ("user", "model")]
                llm_input_messages = hist[-5:] + [{"role": "user", "text": json.dumps(prompt_obj, ensure_ascii=False)}]
                
                print(f"üß† Enviando a Gemini para an√°lisis de imagen: {json.dumps(prompt_obj, ensure_ascii=False, indent=2)}")
                llm_resp_text = await ask_gemini_with_history(llm_input_messages)
                print(f"üß† Respuesta de Gemini (imagen): {llm_resp_text}")

                match_json = re.search(r"\{[\s\S]*\}", llm_resp_text)
                if not match_json:
                    print("‚ö†Ô∏è No se encontr√≥ JSON en la respuesta del modelo para im√°genes.")
                    return False 
                
                action = json.loads(match_json.group())
                
                if not action.get("want_images", False):
                    return False

                if action.get("clarification_needed"):
                    send_whatsapp_message(from_number, action["clarification_needed"])
                    return True 

                target_description = action.get("target")
                if not target_description:
                    send_whatsapp_message(from_number, "No estoy seguro de qu√© im√°genes mostrar. ¬øPodr√≠as ser m√°s espec√≠fico, por favor? ü§î")
                    return True 

                matched_product, matched_variant_catalog_obj = match_target_in_catalog(catalog_data, productos, target_description)

                if not matched_product:
                    send_whatsapp_message(from_number, f"Lo siento, no pude encontrar '{target_description}' en nuestro cat√°logo para mostrarte im√°genes. üòî ¬øQuiz√°s te refieres a otro producto?")
                    return True

                image_urls_to_send = []
                display_name = matched_product["name"]

                if matched_variant_catalog_obj:
                    display_name = f"{matched_product['name']} ({matched_variant_catalog_obj['display_label']})"
                    variant_id_for_images = matched_variant_catalog_obj["id"]
                    # Primero, im√°genes por ID de variante
                    image_urls_to_send = [
                        img["url"] for img in matched_product.get("product_images", [])
                        if img.get("variant_id") == variant_id_for_images
                    ]
                    # Fallback a label si no hay por ID (o si product_images no tiene variant_id pero s√≠ variant_label)
                    if not image_urls_to_send:
                        target_v_label_lower = matched_variant_catalog_obj["catalog_variant_label"].lower()
                        image_urls_to_send = [
                            img["url"] for img in matched_product.get("product_images", [])
                            if img.get("variant_label") and img.get("variant_label").lower() == target_v_label_lower
                        ]
                
                # Si no se encontraron espec√≠ficas de variante O no se pidi√≥ variante, usar generales del producto
                if not image_urls_to_send:
                    image_urls_to_send = [
                        img["url"] for img in matched_product.get("product_images", [])
                        if img.get("variant_id") is None 
                    ]
                
                if not image_urls_to_send:
                    msg_no_img = f"¬°Ay! Parece que no tengo im√°genes para *{display_name}* en este momento. üñºÔ∏èüö´ Pero puedo contarte m√°s sobre el producto si quieres. üòä"
                    send_whatsapp_message(from_number, msg_no_img)
                    return True 

                send_whatsapp_message(from_number, f"¬°Claro que s√≠! Aqu√≠ tienes unas foticos de *{display_name}*:")
                for img_url in image_urls_to_send:
                    try:
                        print(f"üñºÔ∏è Enviando imagen: {img_url} para {display_name}")
                        send_whatsapp_image(from_number, img_url, caption=display_name)
                    except Exception as e:
                        print(f"‚ùå Error enviando imagen {img_url}: {e}")
                return True
            except Exception:
                print(f"‚ö†Ô∏è Error en handle_image_request_logic:\n{traceback.format_exc()}")
                return False


        # --- Comienzo del flujo principal de handle_user_message ---
        image_request_handled = await handle_image_request_logic()
        if image_request_handled:
            print("‚úÖ Solicitud de imagen manejada.")
            return

        print("üìù Procesando como mensaje general o de pedido.")
        
        def build_order_context(productos_list):
            contexto_lines = []
            catalog_data = build_catalog(productos_list) # Usa la misma funci√≥n para consistencia
            for p_entry in catalog_data:
                line = f"**{p_entry['name']}**"
                if p_entry.get('description'):
                    line += f"\n   üìù _{p_entry['description']}_" # Descripci√≥n m√°s visible

                product_obj = next((p for p in productos_list if p['name'] == p_entry['name']), None)
                if not product_obj: continue

                if not product_obj.get("product_variants"):
                    price = product_obj.get('price', 0)
                    stock = product_obj.get('stock', 0)
                    line += f"\n   üí∞ Precio: COP {price:,} (Stock: {stock if stock > 0 else 'Agotado üòü'})"
                else:
                    opts = []
                    for v_prod in product_obj.get("product_variants", []):
                        price = v_prod.get("price", product_obj.get("price", 0))
                        stock = v_prod.get("stock", 0)
                        options_str_parts = [f"{k_opt}:{v_opt_val}" for k_opt, v_opt_val in v_prod.get("options", {}).items()]
                        options_str = ", ".join(options_str_parts)
                        opts.append(f"   variant {options_str} ‚Äî üí∞ COP {price:,} (Stock: {stock if stock > 0 else 'Agotado üòü'})")
                    if opts:
                        line += "\n" + "\n".join(opts)
                    else: # Si hay product_variants pero est√° vac√≠o o malformado
                        price = product_obj.get('price', 0)
                        stock = product_obj.get('stock', 0)
                        line += f"\n   üí∞ Precio base: COP {price:,} (Stock: {stock if stock > 0 else 'Agotado üòü'})"
                
                if p_entry.get("images") or any(v.get("images") for v in p_entry.get("variants",[])):
                     line += f"\n   üñºÔ∏è ¬°Tenemos fotos disponibles! P√≠demelas si quieres verlas."
                contexto_lines.append(line)
            return "--- \nüõçÔ∏è **Nuestro Cat√°logo Actual** üõçÔ∏è\n(Precios en COP. ¬°Preg√∫ntame si quieres ver fotos!)\n\n" + "\n\n".join(contexto_lines) + "\n---"


        instrucciones_gemini = (
            f"Historial de conversaci√≥n previo con el usuario (ignorar si est√° vac√≠o).\n"
            f"Mensaje actual del usuario:```{raw_text}```\n\n"
            f"{build_order_context(productos)}\n\n"
            "**INSTRUCCIONES PARA EL BOT (VENDEDOR HUMANO, AMIGABLE Y PROACTIVO):**\n\n"
            "**Tu Personalidad:**\n"
            "- Eres [Nombre del Bot, ej: VendiBot], un asistente de ventas virtual s√∫per amigable, paciente y con mucho entusiasmo. ¬°Tu meta es que el cliente se sienta como si estuviera hablando con el mejor vendedor de la tienda!\n"
            "- Usa un lenguaje natural, cercano, con jerga colombiana apropiada (ej: '¬°De una!', '¬°Qu√© ch√©vere!', '¬°Con gusto!'). Utiliza emojis para darle vida a tus mensajes (üéâüõíüõçÔ∏èüòäüëçüòâüá®üá¥).\n"
            "- Var√≠a tus frases. No seas repetitivo. Muestra empat√≠a y comprensi√≥n.\n\n"

            "**Flujo de Conversaci√≥n y Ventas:**\n"
            "1.  **Interacci√≥n Inicial:** Responde con calidez. '¬°Hola! üëã Soy [Nombre del Bot], tu asesor de compras hoy. ¬øEn qu√© te puedo colaborar?' o '¬°Qu√© m√°s! ¬øAntojado de algo hoy? Cu√©ntame qu√© buscas. üòâ'\n"
            "2.  **Informaci√≥n de Productos:** Proporciona detalles, precios y stock de forma clara. Si te piden fotos y no se manej√≥ antes, di: '¬°Claro que s√≠! ¬øDe qu√© producto o variante te gustar√≠a ver una fotico para antojarnos m√°s? üì∏'.\n"
            "3.  **Intenci√≥n de Compra (Momento Clave):** Cuando el usuario muestre inter√©s claro en comprar (ej: 'quiero ese', 'me lo llevo', 'voy a pedir X'):\n"
            "    a. **Confirma Productos y Cantidades:** '¬°Excelente elecci√≥n! Entonces, para confirmar: llevas [Producto 1, Cantidad 1] y [Producto 2, Cantidad 2], ¬øcorrecto?'. Si no especifica cantidad, asume 1 pero pregunta si quiere m√°s.\n"
            "    b. **Calcula Subtotal y Env√≠o:** '¬°Perfecto! Tu subtotal ser√≠a de COP [Subtotal]. El env√≠o a cualquier parte tiene un costo de COP 5.000. ¬øEstamos de acuerdo?'.\n"
            "    c. **Pregunta si Desea Algo M√°s (Venta Cruzada Sutil):** '¬øAlguna cosita m√°s que quieras a√±adir a tu pedido o algo m√°s en lo que te pueda ayudar hoy? üòä'.\n"
            "4.  **Recopilaci√≥n de Datos para el Pedido (¬°Hazlo como una conversaci√≥n, no un interrogatorio!):**\n"
            "    - **SOLO SI EL USUARIO CONFIRMA QUE NO DESEA NADA M√ÅS Y QUIERE PROCEDER**, comienza a pedir los datos UNO POR UNO. NO LOS PIDAS TODOS DE GOLPE.\n"
            "    - **Nombre:** '¬°S√∫per! Para coordinar tu env√≠o, ¬øme regalas tu nombre completo, porfa?'\n"
            "    - **Direcci√≥n:** '¬°Mil gracias, [Nombre]! Ahora, ¬øcu√°l es la direcci√≥n completa para hacerte llegar esta maravilla? (Incluye ciudad, barrio, y cualquier detalle extra que nos ayude a encontrarte f√°cil üòâ Ej: Apto, casa, conjunto).' \n"
            "    - **Tel√©fono:** '¬°Anotad√≠simo! Y un n√∫mero de tel√©fono de contacto, por si el mensajero necesita alguna indicaci√≥n el d√≠a de la entrega.'\n"
            "    - **M√©todo de Pago:** '¬°Ya casi terminamos, [Nombre]! Para el pago, ¬øc√≥mo te queda mejor? Aceptamos [Lista tus m√©todos de pago EJ: Nequi, Daviplata, Bancolombia, o si manejas, pago contra entrega].'\n"
            "    - **IMPORTANTE:** Revisa siempre el historial para no pedir datos que ya te hayan dado. Si ya tienes un dato, conf√≠rmalo en lugar de volverlo a pedir (Ej: 'Conf√≠rmame tu tel√©fono, ¬øsigue siendo XXXXX?').\n"
            "5.  **Confirmaci√≥n Final del Pedido ANTES del JSON:**\n"
            "    - **UNA VEZ TENGAS ABSOLUTAMENTE TODOS LOS DATOS REQUERIDOS** (productos con nombre, cantidad y precio unitario; nombre del cliente, direcci√≥n completa, tel√©fono, m√©todo de pago, y el total final incluyendo env√≠o), resume TODO el pedido de forma clara y amigable: '¬°Listo, [Nombre]! ‚ú® Entonces, tu pedido para env√≠o es:\n      [Lista de productos con cantidad y precio unitario]\n      Subtotal: COP [Subtotal]\n      Env√≠o: COP 5.000\n      **Total a Pagar: COP [Total Final]**\n      Se enviar√° a: [Direcci√≥n Completa]\n      Te contactaremos al: [Tel√©fono]\n      Forma de pago: [M√©todo de Pago]\n      ¬øEst√° todo perfecto para que lo ingresemos al sistema y lo despachemos?'\n"
            "    - **SI EL USUARIO CONFIRMA (ej: 's√≠', 'perfecto', 'confirmo'), ENTONCES Y S√ìLO ENTONCES, en tu RESPUESTA FINAL (que debe ser el mensaje de confirmaci√≥n del pedido), incluye el bloque JSON.**\n"
            "    - **Formato JSON EXACTO (sin anteponer 'json' ni explicaciones adicionales, solo el bloque):**\n"
            "      ```json\n"
            "      {\"order_details\":{\"name\":\"NOMBRE_COMPLETO\",\"address\":\"DIRECCION_DETALLADA\",\"phone\":\"TELEFONO_CONTACTO\",\"payment_method\":\"METODO_PAGO_ELEGIDO\",\"products\":[{\"name\":\"NOMBRE_PRODUCTO_1\",\"quantity\":CANTIDAD_1,\"price\":PRECIO_UNITARIO_1}],\"total\":TOTAL_PEDIDO_CON_ENVIO}}\n"
            "      ```\n"
            "6.  **Manejo de Stock y Alternativas:** '¬°Ay, qu√© embarrada! üòî Justo ahora el [Producto] se nos agot√≥. Pero no te preocupes, te podr√≠a ofrecer [Alternativa 1] que es s√∫per parecido y delicioso, o quiz√°s el [Alternativa 2] que tambi√©n est√° volando. ¬øTe suena alguno?'.\n"
            "7.  **Preguntas Generales:** S√© siempre servicial. '¬°Con todo el gusto!', '¬°Para eso estamos!'.\n\n"
            "**Ejemplo de c√≥mo pedir el siguiente dato si ya tienes algunos:**\n"
            "USER: (Ya dio nombre y direcci√≥n)\n"
            "BOT: ¬°Perfecto, [Nombre]! Ya tengo tu direcci√≥n. Ahora, para estar en contacto, ¬øme podr√≠as dar un n√∫mero de tel√©fono donde te podamos localizar? üì±\n\n"
            "**Recuerda:** El objetivo es que el usuario disfrute la conversaci√≥n. ¬°S√© creativo y natural! Si el usuario divaga, trata de guiarlo amablemente de vuelta al proceso de compra si ya hab√≠a mostrado intenci√≥n."
        )

        hist_gemini_general = [m for m in user_histories.get(from_number, []) if m["role"] in ("user", "model")]
        # Enviar un historial m√°s corto para no exceder l√≠mites y mantener relevancia
        llm_input_general = hist_gemini_general[-8:] + [{"role": "user", "text": instrucciones_gemini}]
        
        print(f"üß† Enviando a Gemini para respuesta general/pedido (√∫ltimos {len(llm_input_general)} mensajes)...")
        llm_response_text_general = await ask_gemini_with_history(llm_input_general)
        print(f"üß† Respuesta de Gemini (general/pedido): {llm_response_text_general}")

        order_data_from_json, clean_text_response = extract_order_data(llm_response_text_general)
        current_time_model = datetime.utcnow()

        if clean_text_response and clean_text_response.strip():
            user_histories[from_number].append({
                "role": "model",
                "text": clean_text_response,
                "time": current_time_model.isoformat()
            })
            send_whatsapp_message(from_number, clean_text_response)
            await save_message_to_supabase(from_number, "model", clean_text_response, timestamp=current_time_model)
        else:
            print("‚ö†Ô∏è clean_text_response es None o vac√≠o. El LLM no proporcion√≥ texto conversacional.")
            if not order_data_from_json: # Si tampoco hay JSON, el LLM no respondi√≥ √∫tilmente
                 send_whatsapp_message(from_number, "Hmm, parece que me enred√© un poquito. üòÖ ¬øPodr√≠as repetirme tu consulta, por favor?")


        # Procesar el pedido si el LLM proporcion√≥ order_data_from_json V√ÅLIDO Y COMPLETO
        if order_data_from_json and isinstance(order_data_from_json.get("order_details"), dict):
            order_details_payload = order_data_from_json["order_details"]
            print(f"‚ÑπÔ∏è JSON 'order_details' extra√≠do: {json.dumps(order_details_payload, indent=2)}")

            missing_fields = [
                field for field in REQUIRED_FIELDS 
                if not order_details_payload.get(field) or not str(order_details_payload.get(field)).strip()
            ]
            
            # Adicionalmente, verificar que products y total existan y products no est√© vac√≠o
            if not order_details_payload.get("products") or not isinstance(order_details_payload["products"], list) or not order_details_payload["products"]:
                missing_fields.append("products (lista no vac√≠a)")
            if order_details_payload.get("total") is None: # total puede ser 0, pero no None
                missing_fields.append("total")


            if not missing_fields:
                print(f"‚úÖ Datos de pedido COMPLETOS en JSON listos para procesar: {order_details_payload.get('name')}")
                
                result_order = await process_order(from_number, order_details_payload) 
                status = result_order.get("status")
                # El LLM ya deber√≠a haber enviado el mensaje de "pedido confirmado" ANTES del JSON.
                # Aqu√≠ podr√≠as a√±adir logs o acciones adicionales basadas en el resultado de process_order.

                if status == "created":
                    print(f"‚úÖ Pedido para {from_number} (Cliente: {order_details_payload.get('name')}) CREADO exitosamente en DB. ID: {result_order.get('order_id', 'N/A')}")
                    # Podr√≠as enviar un mensaje de recomendaci√≥n aqu√≠ si lo deseas
                    recommended_prods = await get_recommended_products(order_details_payload.get("products", []))
                    if recommended_prods:
                        texto_recomendaciones = "\n".join(f"  - {r['name']} (COP {r.get('price', 0):,})" for r in recommended_prods)
                        send_whatsapp_message(
                            from_number,
                            f"‚ú® ¬°Por cierto, {order_details_payload.get('name','')}! Ya que tu pedido est√° en camino, quiz√°s te interesen estos otros productos para una pr√≥xima ocasi√≥n o para complementar:\n{texto_recomendaciones}\n\n¬°Av√≠same si algo te llama la atenci√≥n! üòâ"
                        )
                elif status == "updated":
                     print(f"‚ôªÔ∏è Pedido para {from_number} (Cliente: {order_details_payload.get('name')}) ACTUALIZADO exitosamente en DB. ID: {result_order.get('order_id', 'N/A')}")
                elif status == "missing_in_db_logic" or status == "error_saving_to_db": # Estados de error de process_order
                    print(f"‚ö†Ô∏è Error desde process_order para {from_number} (Cliente: {order_details_payload.get('name')}). Status: {status}, Detalles: {result_order.get('fields') or result_order.get('error')}")
                    # Informar al usuario que algo sali√≥ mal en el backend, pero de forma amigable
                    send_whatsapp_message(from_number, f"¬°Hola {order_details_payload.get('name','')}! Tuvimos un peque√±o inconveniente t√©cnico al registrar tu pedido en el sistema final. üõ†Ô∏è No te preocupes, nuestro equipo ya est√° enterado y lo revisar√°. Si no te contactamos pronto, por favor escr√≠benos de nuevo. ¬°Gracias por tu paciencia! üôè")
                else: 
                    print(f"‚ö†Ô∏è Estado no manejado de process_order: {status} para {from_number}")
            
            else: # El JSON existe pero est√° incompleto seg√∫n nuestros REQUIRED_FIELDS
                print(f"‚ö†Ô∏è El LLM envi√≥ un JSON 'order_details', pero est√° INCOMPLETO. Campos faltantes: {missing_fields}. Target: {order_details_payload.get('name', 'N/A')}. La respuesta conversacional del LLM deber√≠a haber pedido estos datos.")
                # No llamamos a process_order. El flujo conversacional del LLM debe continuar pidiendo datos.
                # Si el clean_text_response no fue una pregunta, aqu√≠ se podr√≠a enviar un mensaje gen√©rico pidiendo el dato,
                # pero idealmente el LLM lo maneja.
        
    except Exception:
        print(f"‚ùå [ERROR CR√çTICO en handle_user_message]:\n{traceback.format_exc()}")
        # No enviar el traceback al usuario.
        send_whatsapp_message(from_number, "¬°Uy! Parece que tuve un peque√±o enredo t√©cnico por aqu√≠. ü§ñ ¬øPodr√≠as intentar tu consulta de nuevo en un momentico, por favor? Mil gracias por la paciencia.")